- unittesting
---------------
- Overall, I worked with
	- Unit testing – with unittest mocking or pytest fixture, for mocking 3rd party REST APIs or db interactions
	- Integration testing - to test the end to end flow
	- Regression testing - or load testing to check the load bearing capability
		- used Jmeter scripts for the same. And, python locust module too.
	- API testing with postman & its automation with newman scripts
	- Functional testing With selenium. Wrote python scripts using pyselenium module
	- Also, Behavior Driven Development(BDD) with Behave framework.
	- And, In one project, did security testing using tools like OWASP ZAP or Burp suite, for verifying authentication, authorization, input validations, vulnerability scanning, etc.

- Generally, we follow TDD - test driven development
- It means that
	- first I will write the code skeleton
	- next, write the unit tests, and
	- then, modify the code logic to address these test cases.
	- Finally, when both the newly created and existing test cases, are successful,
	  will commit the code.
- This way, we can ensure that code is more reliable, handling all edge cases.
- Also, any further logic changes, will be integrable easily, as all test cases need to pass, before pushing the code

- Advantages of Unit testing
	It helps you to detect bugs early in the development cycle
	It helps you to write better programs
	It syncs easily with other testing methods and tools
	It will have many fewer bugs
	It is easier to modify in future with very less consequence

- Disadvantages/Problems with unit testing
	Initially time taking
	But subsequently, it will be fast, after each Iteration
	As code is more reliable, there are very less chances of code related production issues.

In Unittesting, for each test suite, there will be
	a pair of class methods, called setup and tearDown
	and pair of instance methods, called setup and tearDown

		setup class method 		-- executes at the start of the test suite
		tearDown class method 	--  executes at the end of the test suite

		setup instance method 	-- executes at the start of each test case
		tearDown instance method – executes at end of each test case

- Unittesting vs integration testing
	- In unit testing, we mock the interactions will 3rd party REST APIs, or databases,
	  as the primary focus is to test our source code.
	- In integration testing, as the primary objective is to test end-to-end functionality,
	  there won't be any mockings.

- HappyPath testing
	- It is a type of software testing that uses known input and produces an expected output
	- It is also called positive testing.

	Positive test cases describe happy path scenarios, where errors result in failed tests.
	Negative test cases describe unhappy path scenarios, where expected errors result in passed tests.


- According to Martin Fowler, creator of unit tests,
	- Dummy objects
		are passed around but never actually used.
		Usually they are just used to fill parameter lists.
	- Fake objects
		actually have working implementations, but usually take some shortcut which
		makes them not suitable for production (an in memory database is a good example).
	- Stubs
		provide canned answers to calls made during the test, usually not responding
		at all to anything outside what's programmed in for the test.
		Stubs may also record information about calls, such as an email gateway stub
		that remembers the messages it 'sent', or maybe only how many messages it 'sent'.
	- Mocks
		are what we are talking about here: objects pre-programmed with expectations
		which form a specification of the calls they are expected to receive.

- stubs vs mocks
	- A Stub is used to fill in some dependency required for unit test to run correctly.
	- A Mock is a fake object which runs the tests where we put assert.


- defect tracking tools can be used:

	1) To track the status of bugs.
		- Defect tracking tools can be used to track the status of bugs, including the date the bug was reported, the person who reported it, the steps to reproduce the bug, the severity of the bug, and the status of the bug (e.g., open, in progress, fixed).
	2) To prioritize bugs.
		- Defect tracking tools can be used to prioritize bugs based on their severity and impact. This helps to ensure that the most important bugs are fixed first.
	3) To track the progress of bug fixes.
		- Defect tracking tools can be used to track the progress of bug fixes. This helps to ensure that bugs are fixed in a timely manner.
	4) To communicate with stakeholders.
		- Defect tracking tools can be used to communicate with stakeholders about the status of bugs. This helps to keep stakeholders informed about the progress of bug fixes and to get their feedback.
	5) To generate reports.
		- Defect tracking tools can be used to generate reports about the status of bugs. This information can be used to improve the quality of software and to identify areas where improvement is needed.
